/* 
 * ================================================================================
 * unibo.basicrobot23
 * ================================================================================
 */  
   
System /* -trace -msglog  */ basicrobot23    

Dispatch cmd       	: cmd(MOVE)      
Dispatch end       	: end(ARG)   
 
Request step       : step(TIME)	
Reply stepdone     : stepdone(V)  
Reply stepfailed   : stepfailed(DURATION, CAUSE)

Event  sonardata   : sonar( DISTANCE ) 	     
Event obstacle     : obstacle(X) 

Request engage        : engage(ARG)	
Reply   engagedone    : engagedone(ARG)
Reply   engagerefused : engagerefused(ARG)

Dispatch disengage    : disengage(ARG)
Dispatch engaged      : engaged(ARG)
 
Context ctxbasicrobot ip [host="localhost" port=8020]  

//CodedQActor datacleaner    context ctxbasicrobot className "rx.dataCleaner"
//CodedQActor distancefilter context ctxbasicrobot className "rx.distanceFilter"
  
QActor engager context ctxbasicrobot{
[#     
  var Owner = "unkknown"
  var curConn : Interaction? = null 
#]  	
	State s0 initial { 	  
		printCurrentMessage
	}
	Transition t0 whenRequest engage -> engageAccept
	              whenEvent sonardata -> handleEvent
     			   
    State handleEngage{
    	printCurrentMessage
    	replyTo engage with engagedone : engagedone(ok)    	
    }
    State engageRefuse{
    	[# CommUtils.outmagenta("engagerefused since working for by $Owner" ) #]
    	replyTo engage with engagerefused : engagerefused($Owner)
    }
    Goto s0  
    
    State engageAccept{	
    	printCurrentMessage
			onMsg( engage : engage(OWNER) ) {
				[# if( currentMsg.conn != null ) curConn = currentMsg.conn					
				   Owner  = payloadArg(0)
				   if( curConn != null )
				   CommUtils.outmagenta("engager | engaged by remote $Owner  on $curConn" )		
				   else 		   
				   CommUtils.outmagenta("engager | engaged by local $Owner = ${payloadArg(0)} " )	
				#]
				replyTo engage with engagedone : engagedone($Owner)
				forward basicrobot    -m engaged : engaged($Owner)
				 
			}
	} 
	Goto s0
	 
	State handleEvent{
		printCurrentMessage
		[# CommUtils.outcyan("handleEvent $currentMsg") 
		   //val Data = currentMsg.msgContent()
		   val info = currentMsg.toString()
		   if( curConn != null ) CommUtils.forwardOnInterconn(curConn,info) //invio l'evento al caller'
		#]
 	}
	
	Transition t0 whenEvent sonardata -> handleEvent
	              whenEvent obstacle  -> handleEvent
}
 
QActor basicrobot context ctxbasicrobot{
[#  
  var StepTime      = 0L
  var StartTime     = 0L     
  var Duration      = 0L   
  var RobotType     = "" 
  var CurrentMove   = "unkknown"
  var StepSynchRes  = false
  var Owner         = "unkknown"
  
  fun checkOwner() : Boolean {
  	CommUtils.outblue("                    checkOwner $Owner ${currentMsg}")
  	return ( currentMsg.msgContent().contains( Owner ) || currentMsg.isEvent() )
  }
#]   
 	State ss0 initial { 	
 		printCurrentMessage       
 		discardMsg On  //In the intial phase ...
 		
 		delegate "engage" to engager
  		
 		//[# unibo.comm22.utils.CommSystemConfig.tracing = false #]  //tracing at unibo.comm22 level
		println("basicrobot | STARTS")	
		//[# sysUtil.trace = true #]  //Trace the behavior of ActorBasic
 		qrun uniborobots.robotSupport.create(myself,"basicrobotConfig.json")	
 		
 		[# RobotType = uniborobots.robotSupport.robotKind #]
  		run uniborobots.robotSupport.move( "a" )    //synch
 		run uniborobots.robotSupport.move( "d" )	//synch
        updateResource [# "basicrobot(started)" #]
 	} 
	Transition t0 whenMsg engaged -> work
 	
	State work{ 
		printCurrentMessage
		discardMsg Off //We want store the non-handled messages
		onMsg( engaged : engaged(OWNER)){
			[# Owner  = payloadArg(0) #]
		}
		println("basicrobot  | waiting .................. ")  
	} 
	Transition t0   whenRequest  step     -> doStep		
					whenMsg     cmd   and [# checkOwner()  #]  -> execcmd
				  	whenMsg     end   and [# checkOwner()  #]  -> endwork			  
	
	State execcmd{
		printCurrentMessage
			onMsg( cmd : cmd(MOVE) ){
	  			//activate the motors  
	  			[# CurrentMove = payloadArg(0) #]
				run uniborobots.robotSupport.move( payloadArg(0 ) )
				updateResource [# "moveactivated(${payloadArg(0)})" #]
			}
	 }
	 Goto work   
  
	
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime     = payloadArg(0).toLong()  	#]    
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doing doStep StepTime=$StepTime  ")        
        [# StepSynchRes = uniborobots.robotSupport.dostep( StepTime ) #]   
	}  	
		Goto stepok if [# StepSynchRes #] else stepKo 
 
     	 
	State stepok{   
		printCurrentMessage
 		run uniborobots.robotSupport.move( "h" )  //stop the (real) robot 
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone($StepTime)
		println("basicrobot | stepDone reply done")
  	}
	Goto work  
 
	State stepKo{  	 	
		printCurrentMessage
		setDuration Duration from StartTime
		run uniborobots.robotSupport.move( "h" )  //stop the (real) robot
		[# var TunedDuration   =  ((Duration * 0.80)).toLong()   #]
		println("basicrobot | stepFail duration=$Duration  TunedDuration=$TunedDuration")
			run uniborobots.robotSupport.move( "s" )
			delayVar TunedDuration 
			run uniborobots.robotSupport.move( "h" ) 
 		updateResource [# "stepFail($Duration)" #] 
 		replyTo step with stepfailed : stepfailed($Duration, obst)
    } 
	Goto work

					
	State endwork{ 
		updateResource [# "basicrobot(end)" #]	 		
 		terminate 1
	}   
   
}

QActor basicrobotusage context ctxbasicrobot{
	State ss0 initial { 	
		printCurrentMessage color black
		delay 1000
		request basicrobot -m engage : engage( basicrobotusage )
	}
	Transition t0 whenReply engagedone -> dowork
	
	State dowork{
		//forward basicrobot -m cmd : cmd(p)
		request basicrobot -m step : step(350)
	}
	Transition t0 whenReply stepdone   -> handleStepDone
	              whenReply stepfailed -> handleStepFail
	
	State handleStepDone{
		printCurrentMessage color black
	}
	Goto dowork
	
	State handleStepFail{
		printCurrentMessage color black
	}
}
 